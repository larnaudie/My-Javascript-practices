import { join, extname } from 'path';
import { promises as fs } from 'fs';
import extractZip from 'extract-zip';
import { downloadArtifact as downloadElectronAssets } from '@electron/get';
import { launcher as ChromedriverServiceLauncher, } from 'wdio-chromedriver-service';
import { getDirname } from 'cross-dirname';
import { log } from './utils.js';
const dirname = getDirname();
function downloadAssets(version) {
    const conf = {
        version,
        artifactName: 'chromedriver',
        force: process.env.force_no_cache === 'true',
        cacheRoot: process.env.electron_config_cache,
        platform: process.env.npm_config_platform,
        arch: process.env.npm_config_arch,
        // rejectUnauthorized: process.env.npm_config_strict_ssl === 'true',
        // quiet: ['info', 'verbose', 'silly', 'http'].indexOf(process.env.npm_config_loglevel) === -1
    };
    log.debug('chromedriver download config: ', conf);
    return downloadElectronAssets(conf);
}
async function attemptAssetsDownload(version = '') {
    log.debug(`downloading Chromedriver for Electron v${version}...`);
    try {
        const targetFolder = join(dirname, '..', 'bin');
        const zipPath = await downloadAssets(version);
        log.debug('assets downloaded to ', zipPath);
        await extractZip(zipPath, { dir: targetFolder });
        log.debug('assets extracted');
        const platform = process.env.npm_config_platform || process.platform;
        if (platform !== 'win32') {
            log.debug('setting file permissions...');
            await fs.chmod(join(targetFolder, 'chromedriver'), 0o755);
            log.debug('permissions set');
        }
    }
    catch (err) {
        // check if there is a semver minor version for fallback
        const parts = version.split('.');
        const baseVersion = `${parts[0]}.${parts[1]}.0`;
        if (baseVersion === version) {
            log.error(`error downloading Chromedriver for Electron v${version}`);
            log.error(err);
            throw err;
        }
        log.warn(`error downloading Chromedriver for Electron v${version}`);
        log.debug('falling back to minor version...');
        await attemptAssetsDownload(baseVersion);
    }
}
export default class ChromeDriverLauncher extends ChromedriverServiceLauncher {
    constructor(options, capabilities, config) {
        const isWin = process.platform === 'win32';
        const chromedriverServiceOptions = options.chromedriver || {};
        log.debug('launcher received options:', options);
        process.env.WDIO_ELECTRON = 'true';
        const validChromedriverPath = chromedriverServiceOptions.chromedriverCustomPath !== undefined || options.electronVersion !== undefined;
        if (!validChromedriverPath) {
            const invalidChromedriverOptsError = new Error('You must specify the electronVersion, or provide a chromedriverCustomPath value');
            log.error(invalidChromedriverOptsError);
            throw invalidChromedriverOptsError;
        }
        const shouldDownloadChromedriver = options.electronVersion && (!options.chromedriver || !options.chromedriver.chromedriverCustomPath);
        if (isWin) {
            const shouldRunInNode = extname(chromedriverServiceOptions.chromedriverCustomPath || '') === '.js';
            if (shouldRunInNode) {
                process.env.WDIO_ELECTRON_NODE_PATH = process.execPath;
                process.env.WDIO_ELECTRON_CHROMEDRIVER_PATH = chromedriverServiceOptions.chromedriverCustomPath;
                chromedriverServiceOptions.chromedriverCustomPath = join(dirname, '..', 'bin', 'chromedriver.bat');
            }
        }
        if (!chromedriverServiceOptions.chromedriverCustomPath) {
            const chromedriverExecutable = isWin ? 'chromedriver.exe' : 'chromedriver';
            chromedriverServiceOptions.chromedriverCustomPath = join(dirname, '..', 'bin', chromedriverExecutable);
        }
        log.debug('setting chromedriver service options:', chromedriverServiceOptions);
        super(chromedriverServiceOptions, capabilities, config);
        this.electronServiceLauncherOptions = options;
        this.shouldDownloadChromedriver = shouldDownloadChromedriver;
    }
    async onPrepare() {
        if (this.shouldDownloadChromedriver) {
            const { electronVersion } = this.electronServiceLauncherOptions;
            await attemptAssetsDownload(electronVersion);
        }
        return super.onPrepare();
    }
}
//# sourceMappingURL=launcher.js.map